# 理论

## 1 排序算法分析

### 1.1 执行效率 - 时间复杂度

衡量排序算法在不同数据情况（有序度）下的性能表现  
1 最好情况、最坏情况、平均情况时间复杂度   
2 时间复杂度的系数、常数、低阶
3 比较次数和交换（移动）次数

### 1.2 内存消耗 - 空间复杂度

原地排序（in-place）  
非原地排序

### 1.3 稳定性

稳定：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

## 2 排序算法
基于比较的排序：O(n^2)（冒泡排序、插入排序、选择排序），O(nlogn)（归并排序，快速排序）  
非基于比较的排序：O(n)线性排序算法（桶排序、计数排序、基数排序）  

### 2.1 基于比较的排序算法

基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。

#### 2.1.1 冒泡排序
时间复杂度O(n^2)，空间复杂度O(1)  
稳定  
算法：外层循环表示n-1个轮次的比较，内层循环表示本轮的比较。每轮比较解决一个元素的位置。  
优化：如果本轮比较中没有元素交换位置，说明所有元素都已在正确位置。

#### 2.1.2 插入排序
时间复杂度O(n^2)，空间复杂度O(1)  
稳定
算法：已排序区间|未排序区间，每次取未排序区间的第一个元素在已排序区间中寻找插入的合适位置。

### 2.1.3 选择排序
时间复杂度O(n^2)，空间复杂度O(1)  
不稳定  
算法：已排序区间|未排序区间，每次找未排序区间中最小值放在已排序区间末尾的下一个位置。

#### 2.1.4 归并排序
时间复杂度O(nlogn)，空间复杂度O(n)  
分治，稳定  

[归并排序-python实现](../00-base/01-comparison/04-merge-sort.py)

#### 2.1.5 快速排序
时间复杂度O(nlogn)、空间复杂度O(n)    
分治，不稳定  
最坏时间复杂度情况O(n^2)-初始就有序，每层遍历都是从0~n-1，没有分治  

[快速排序-python实现](../00-base/01-comparison/05-quick-sort.py)  

### 2.2 非基于比较的排序算法
线性时间复杂度，原因是不基于比较  

#### 2.2.1 桶排序（Bucket Sort）
将数据区间分为多个有顺序的子区间，子区间内使用O(nlogn)排序算法排序，合并所有子区间（子区间有自然顺序，所以拼接即可）。  

（缺点）桶排序对要排序数据的要求非常苛刻： 
1 待排序数据要很容易划分成 m 个天然大小顺序的桶区间    
2 数据在各个桶区间分布均匀，在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn)      

> 桶排序算法的时间复杂度分析：  
> 
> 如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。
> 每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，
> 因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。
> 当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。 


适用场景：外部排序（数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中）

> 10GB 的订单数据，希望按订单金额（假设金额都是正整数）进行排序，
> 但是内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。
> 
> 1 扫描一遍文件，确定金额区间`[min_amount, max_amount]`  
> 2 将金额区间分为 n/m 个子区间，n为订单数据存储大小，m为内存大小    
> 3 如果某区间数据量大于内存大小，继续对该子区间进行子区间划分  
> 4 对每个子区间使用O(nlogn)排序算法排序  
> 5 合并所有子区间  

#### 2.2.2 计数排序（Counting Sort）

适用场景：计数排序只能用在数据范围不大的场景中。
> 1 如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。
> 因为数据范围很大时，要创建长度很长的计数数组  
> 
> 2 计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。  
> 例：如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。  
> 例：如果要排序的数据中有负数，数据的范围是$[-1000, 1000]$，那我们就需要先对每个数据都加 1000，转化成非负整数。

#### 2.2.3 基数排序（Radix Sort）
**算法描述：**   
1 待排序数据元素，长度对齐（末尾补'0'，因为ASCII码中所有字母都大于'0'）    
2 待排序数据元素，分割出独立的“位”  
3 对所有数据元素，按照独立的“位”排序，从后往前，依次排序  


**时间复杂度分析：**  
如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，
总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。

**待排序数据要求：**  
1 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。    
2 每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。  

**每位排序算法要求：** 每位来排序的排序算法要是稳定的，一般选择。
> 因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，那么低位的排序就完全没有意义了。


