# 堆-理论
## 1.1 堆-定义
堆是一种特殊的树，需满足两点：  
1 堆是一个完全二叉树（除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列）  
2 堆中每个节点的值必须大于等于（或小于等于）其子树中每个节点的值（另一种表述：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值）  

## 1.2 堆-实现
### 1.2.1 存储
数组（完全二叉树适合使用数组存储） 
数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 i/2 的节点

### 1.2.2 堆化
时间复杂度O(logn)（n个节点树的高度为O(logn)）  

#### 1.2.2.1 从上往下堆化（堆删除）

#### 1.2.2.2 从下往上堆化（堆插入）

### 1.2.3 插入
将新元素插入堆数组的末尾，为了重新满足堆的两个条件，需要进行堆化  

### 1.2.4 删除堆顶元素
堆顶元素存储的就是堆中数据的最大值或者最小值。

删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。

最后一个节点元素放在堆顶，并从上往下堆化  

## 1.3 堆排序
借助堆实现的排序算法，不是稳定的排序算法（堆化可能改变相等元素前后顺序），但是时间复杂度非常稳定。  
> 堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

算法步骤：  
1 建堆O(n)，叶子节点无需从上往下堆化，所以从最后一个非叶子节点开始处理，其索引位置为n//2（下标范围1~n），或者(n-1)//2（下标范围0~n-1）    
2 依次取堆顶元素，之后删除堆顶元素并将最后一个元素放在堆顶，从上往下堆化O(nlogn)  

两种排序算法的时间复杂度都是 O(nlogn)，甚至堆排序比快速排序的时间复杂度还要稳定，但是，在实际的软件开发中，快速排序的性能要比堆排序好，这是为什么？  
1 堆排序数据访问的方式没有快速排序友好  
2 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序  

> 快速排序数据交换的次数不会比逆序度多。但是堆排序的第一步是建堆，
> 建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。
> 比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。



